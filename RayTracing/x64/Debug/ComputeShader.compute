RWTexture2D<float4> renderTarget : register(u0);

cbuffer GlobalVars : register(b0)
{
	float3 nearPlaneUp;
	float width;
	float3 nearPlaneSide;
	float height;

	float3 nearPlaneCenter;
	int sphereCount;

	float3 mCameraPos;
	int lightCount;	
};



struct Sphere
{
	float3 center;
	float radius;
	float4 color;

	float3 boundingBoxMin;
	float padding1;
	float3 boundingBoxMax;
	float padding2;
};

struct ChildPoint
{
	float minT;
	int childIndex;
};

struct OctreeNodeGPU
{
	float3 boxMin;
	int isLeaf;

	float3 boxMax;
	float padding;

	int4 childIndices[2];
};

struct Light
{
	float3 position;
	float padding;

	float4 color;
};

struct Ray
{
	float3 origin;
	float3 direction;
};

struct IntersectionPoint
{
	float3 position;
	float3 normal;
	float4 color;
};

StructuredBuffer<Sphere> spheres : register(t0);
StructuredBuffer<Light> lights : register(t1);
StructuredBuffer<OctreeNodeGPU> octree : register(t2);

float4 PhongIllumination(const IntersectionPoint intersectionPoint, const Ray ray, const Light light)
{
	float specularPower = 40.0f;
	float4 totalColor;
	const float3 surfaceNormal = intersectionPoint.normal;
	float3 surfaceToLight = light.position - intersectionPoint.position;
	float3 viewDir = normalize(intersectionPoint.position - mCameraPos);
	float surfaceToLightLen = length(surfaceToLight);
	surfaceToLight /= surfaceToLightLen;
	float NoL = saturate(dot(surfaceNormal, surfaceToLight));

	totalColor = intersectionPoint.color * light.color * NoL / (surfaceToLightLen * surfaceToLightLen);
	float3 h = normalize(surfaceToLight + viewDir);
	float NoH = saturate(dot(surfaceNormal, h));
	totalColor += pow(NoH, specularPower) * intersectionPoint.color * light.color / (surfaceToLightLen * surfaceToLightLen);
	return totalColor;
}

void CalculateShadowRay(const IntersectionPoint intersectionPoint, const Ray ray, const Light light,out Ray shadowRay)
{
	shadowRay.direction = normalize(light.position - intersectionPoint.position);
	shadowRay.origin = intersectionPoint.position + float3(0.005, 0.005, 0.005) * intersectionPoint.normal;
}



bool RaySphereIntersection(Sphere sphere, const Ray ray,out float t)
{
	float3 o_c = ray.origin - sphere.center;
	float dDotD = dot(ray.direction, ray.direction);

	float delta = pow(dot(ray.direction, (o_c)), 2)
		- dDotD *(dot(o_c, o_c) - pow(sphere.radius, 2));

	if (delta < 0)
	{
		return false;
	}
	else
	{
		float t1 = (-dot(ray.direction, o_c) + sqrt(delta)) / dDotD;
		float t2 = (-dot(ray.direction, o_c) - sqrt(delta)) / dDotD;

		float minRoot;
		float maxRoot;
		if (t1 > t2)
		{
			minRoot = t2;
			maxRoot = t1;
		}
		else
		{
			minRoot = t2;
			maxRoot = t1;
		}

		if (minRoot < 0)
		{
			if (maxRoot < 0)
			{
				return false;
			}
			else
			{
				t = maxRoot;
				return true;
			}
		}
		else
		{
			t = minRoot;
			return true;
		}
	}
}

bool RayPlaneIntersection(const float3 n, const float3 p0, const Ray ray,out float t)
{
	float denom = dot(n, ray.direction);
	if (denom > 1e-6) {
		float3 p0l0 = p0 - ray.origin;
		t = dot(p0l0, n) / denom;
		return (t >= 0);
	}

	return false;
}

/*bool FindClosestIntersection(Ray ray, out IntersectionPoint intersectionPoint, out float t)
{
	intersectionPoint.position = 0;
	intersectionPoint.color = 0;
	intersectionPoint.normal = 0;

	float minT = 5873200;
	int minIndex = -1;

	for (int i = 0; i < sphereCount; i++)
	{
		if (RaySphereIntersection(spheres[i], ray, t))
		{
			if (t < minT)
			{
				minIndex = i;
				minT = t;
			}
		}
	}

	float sceneT=0;


	if (minIndex != -1)
	{
		sceneT = minT;
		intersectionPoint.position = ray.origin + ray.direction * sceneT;
		intersectionPoint.color = spheres[minIndex].color;
		intersectionPoint.normal = normalize(intersectionPoint.position - spheres[minIndex].center);
		//return true;
	}
	//else
	//{
	//	intersectionPoint.position = 0;
	//	intersectionPoint.color = 0;
	//	intersectionPoint.normal = 0;
	//	return false;
	//}

	float groundT=0;
	bool intersectionWithScene = minIndex != -1;
	bool intersectionWithGround = RayPlaneIntersection(float3(0, 0, -1), float3(0, 0, -10), ray, groundT);
	if (intersectionWithScene || intersectionWithGround)
	{
		if (intersectionWithScene && intersectionWithGround)
		{
			if (groundT < sceneT)
			{
				intersectionPoint.normal = float3(0, 0, 1);
				intersectionPoint.position = ray.origin + ray.direction * groundT;
				intersectionPoint.color = float4(0.6, 0.6, 0.6, 1);				
				
				t = groundT;
			}
			else
			{
				t = sceneT;
			}
		}
		else
		{
			if (intersectionWithScene)
			{
				t = sceneT;
			}
			else
			{
				intersectionPoint.normal = float3(0, 0, 1);
				intersectionPoint.position = ray.origin + ray.direction * groundT;
				intersectionPoint.color = float4(0.6, 0.6, 0.6, 1);
				t = groundT;
			}
		}
		return true;
	}
	return false;
}*/

bool CheckRayBoxIntersection(const Ray ray, const float3 boxMin, const float3 boxMax, out float outTMin)
{
	float tmin = -5873200, tmax = 5873200;

	if (ray.direction.x != 0.0) 
	{
		float tx1 = (boxMin.x - ray.origin.x) / ray.direction.x;
		float tx2 = (boxMax.x - ray.origin.x) / ray.direction.x;

		tmin = max(tmin, min(tx1, tx2));
		tmax = min(tmax, max(tx1, tx2));
	}

	if (ray.direction.y != 0.0) {
		float ty1 = (boxMin.y - ray.origin.y) / ray.direction.y;
		float ty2 = (boxMax.y - ray.origin.y) / ray.direction.y;

		tmin = max(tmin, min(ty1, ty2));
		tmax = min(tmax, max(ty1, ty2));
	}

	if (ray.direction.z != 0.0) {
		float tz1 = (boxMin.z - ray.origin.z) / ray.direction.z;
		float tz2 = (boxMax.z - ray.origin.z) / ray.direction.z;

		tmin = max(tmin, min(tz1, tz2));
		tmax = min(tmax, max(tz1, tz2));
	}
	outTMin = tmin;
	return tmax >= tmin;
}


bool OctreeFindClosestIntersection(const Ray ray, IntersectionPoint intersectionPoint, float t)
{
	OctreeNodeGPU treeStack[40];
	int stackCount = 0;
	treeStack[stackCount] = octree[0];
	stackCount++;
	while (stackCount != 0)
	{			
		OctreeNodeGPU currentNode = treeStack[stackCount - 1];
		stackCount--;

		if(currentNode.isLeaf)
		{
			float minT = 5873200;
			int minIndex = -1;

			/*for (int i = 0; i < currentNode->spheres.size(); i++)
			{
			
				if(RaySphereIntersection(spheres[i], ray, t))
				//if (RaySphereIntersection(*(currentNode->spheres[i]), ray, t))
				{
					if (t < minT)
					{
						minIndex = i;
						minT = t;
					}
				}
			}*/

			if (minIndex != -1)
			{
				t = minT;
				//intersectionPoint.position = ray.origin + ray.direction * t;
				//intersectionPoint.color = currentNode->spheres[minIndex]->color;
				//intersectionPoint.normal = glm::normalize(intersectionPoint.position - currentNode->spheres[minIndex]->center);

				intersectionPoint.position = 0;
				intersectionPoint.color = 0;
				intersectionPoint.normal = 0;

				return true;
			}
			else
			{
				continue;
			}
		}
		else
		{
			int tempchildIndices[8] = (int[8])currentNode.childIndices;

			int foundIntersection = 0;
			ChildPoint indexDistancePairs[8];
			for (int i = 0; i < 8; i++)
			{
				float intT;
				if (CheckRayBoxIntersection(ray, octree[tempchildIndices[i]].boxMin, octree[tempchildIndices[i]].boxMax, intT))
				{						
					indexDistancePairs[foundIntersection].minT = intT;
					indexDistancePairs[foundIntersection].childIndex = tempchildIndices[i];
					foundIntersection++;
				}
			}
			//sort
			int n = foundIntersection;
			while(1)
			{
				bool swapped = false;
				for (int j = 1; j < foundIntersection; j++)
				{
					if(indexDistancePairs[j - 1].minT > indexDistancePairs[j].minT)
					{
						ChildPoint tempCP = indexDistancePairs[j - 1];
						indexDistancePairs[j - 1] = indexDistancePairs[j];
						indexDistancePairs[j] = tempCP;
						swapped = true;
					}
				}
				n--;
				if(!swapped)
					break;
			}
			//sort

			for (int k = 0; k < foundIntersection; k++)
			{
				treeStack[stackCount] = octree[indexDistancePairs[k].childIndex];
				stackCount++;
			}			
		}			
	}

	return false;	
}


bool FindClosestIntersection(Ray ray, out IntersectionPoint intersectionPoint, out float t)
{

	float sceneT;
	float groundT;
	bool intersectionWithScene = OctreeFindClosestIntersection(ray, intersectionPoint, sceneT);
	bool intersectionWithGround = RayPlaneIntersection(float3(0, 0, -1), float3(0, 0, -10), ray, groundT);
	if (intersectionWithScene || intersectionWithGround)
	{
		if (intersectionWithScene && intersectionWithGround)
		{
			if (groundT < sceneT)
			{
				intersectionPoint.normal = float3(0, 0, 1);
				intersectionPoint.position = ray.origin + ray.direction * groundT;
				intersectionPoint.color = float4(0.6, 0.6, 0.6,1);
				t = groundT;
			}
			else
			{
				t = sceneT;
			}
		}
		else
		{
			if (intersectionWithScene)
			{
				t = sceneT;
			}
			else
			{
				intersectionPoint.normal = float3(0, 0, 1);
				intersectionPoint.position = ray.origin + ray.direction * groundT;
				intersectionPoint.color = float4(0.6, 0.6, 0.6, 1);
				t = groundT;
			}
		}
		return true;
	}
	return false;
}

bool InShadow(const Ray shadowRay, const Light light)
{
	IntersectionPoint intersectionPoint;
	float maxT = length(light.position - shadowRay.origin);
	float intersectionT;
	if (FindClosestIntersection(shadowRay, intersectionPoint, intersectionT) && intersectionT < maxT)
	{
		return true;
	}

	return false;
}

float4 Shade(const IntersectionPoint intersectionPoint, const Ray ray)
{
	float4 output = 0;
	//TODO ambient?
	Ray shadowRay;

	for (int i = 0; i < lightCount; i++)
	{
		CalculateShadowRay(intersectionPoint, ray, lights[i], shadowRay);

		if (!InShadow(shadowRay, lights[i]))
		{
			output += PhongIllumination(intersectionPoint, ray, lights[i]);
		}
	}

	return output;
}

void Trace(Ray ray, out float4 outputColor)
{
	IntersectionPoint intersectionPoint;
	float t;
	if (FindClosestIntersection(ray, intersectionPoint, t))
	{
		outputColor = Shade(intersectionPoint, ray);
	}
	else
	{
		outputColor = float4(0.5, 0.5, 0.5, 1);
	}
}

[numthreads(16,16,1)]
void main(uint3 threadId : SV_DispatchThreadID)
{
	float2 ssPos = float2(threadId.xy);
	float2 dimension = float2(width, height);
	ssPos = ssPos / dimension;
	ssPos = ssPos * 2 - 1;

	float3 pixelWorldPos = nearPlaneCenter + nearPlaneUp * -ssPos.y + nearPlaneSide * ssPos.x;
	float3 rayDir = normalize(pixelWorldPos - mCameraPos);
	Ray ray;
	ray.direction = rayDir;
	ray.origin = mCameraPos;
	float4 oc;
	Trace(ray, oc);

	renderTarget[uint2(threadId.x, threadId.y)] = oc;
}

