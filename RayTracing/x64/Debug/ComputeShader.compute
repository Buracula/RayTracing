RWTexture2D<float4> renderTarget : register(u0);

cbuffer GlobalVars : register(b0)
{
	float3 nearPlaneUp;
	float width;
	float3 nearPlaneSide;
	float height;

	float3 nearPlaneCenter;
	int sphereCount;

	float3 mCameraPos;
	int lightCount;	
};

struct Sphere
{
	float3 center;
	float radius;
	float4 color;

	float3 boundingBoxMin;
	float padding1;
	float3 boundingBoxMax;
	float padding2;
};

struct OctreeNodeGPU
{
	float3 boxMin;
	int isLeaf;

	float3 boxMax;
	float padding;

	int4 childIndices[2];
};

struct Light
{
	float3 position;
	float padding;

	float4 color;
};

struct Ray
{
	float3 origin;
	float3 direction;
};

struct IntersectionPoint
{
	float3 position;
	float3 normal;
	float4 color;
};

StructuredBuffer<Sphere> spheres : register(t0);
StructuredBuffer<Light> lights : register(t1);
StructuredBuffer<OctreeNodeGPU> octree : register(t2);

float4 PhongIllumination(const IntersectionPoint intersectionPoint, const Ray ray, const Light light)
{
	float specularPower = 40.0f;
	float4 totalColor;
	const float3 surfaceNormal = intersectionPoint.normal;
	float3 surfaceToLight = light.position - intersectionPoint.position;
	float3 viewDir = normalize(intersectionPoint.position - mCameraPos);
	float surfaceToLightLen = length(surfaceToLight);
	surfaceToLight /= surfaceToLightLen;
	float NoL = saturate(dot(surfaceNormal, surfaceToLight));

	totalColor = intersectionPoint.color * light.color * NoL / (surfaceToLightLen * surfaceToLightLen);
	float3 h = normalize(surfaceToLight + viewDir);
	float NoH = saturate(dot(surfaceNormal, h));
	totalColor += pow(NoH, specularPower) * intersectionPoint.color * light.color / (surfaceToLightLen * surfaceToLightLen);
	return totalColor;
}

void CalculateShadowRay(const IntersectionPoint intersectionPoint, const Ray ray, const Light light,out Ray shadowRay)
{
	shadowRay.direction = normalize(light.position - intersectionPoint.position);
	shadowRay.origin = intersectionPoint.position + float3(0.005, 0.005, 0.005) * intersectionPoint.normal;
}



bool RaySphereIntersection(Sphere sphere, const Ray ray,out float t)
{
	float3 o_c = ray.origin - sphere.center;
	float dDotD = dot(ray.direction, ray.direction);

	float delta = pow(dot(ray.direction, (o_c)), 2)
		- dDotD *(dot(o_c, o_c) - pow(sphere.radius, 2));

	if (delta < 0)
	{
		return false;
	}
	else
	{
		float t1 = (-dot(ray.direction, o_c) + sqrt(delta)) / dDotD;
		float t2 = (-dot(ray.direction, o_c) - sqrt(delta)) / dDotD;

		float minRoot;
		float maxRoot;
		if (t1 > t2)
		{
			minRoot = t2;
			maxRoot = t1;
		}
		else
		{
			minRoot = t2;
			maxRoot = t1;
		}

		if (minRoot < 0)
		{
			if (maxRoot < 0)
			{
				return false;
			}
			else
			{
				t = maxRoot;
				return true;
			}
		}
		else
		{
			t = minRoot;
			return true;
		}
	}
}

bool RayPlaneIntersection(const float3 n, const float3 p0, const Ray ray,out float t)
{
	float denom = dot(n, ray.direction);
	if (denom > 1e-6) {
		float3 p0l0 = p0 - ray.origin;
		t = dot(p0l0, n) / denom;
		return (t >= 0);
	}

	return false;
}

bool FindClosestIntersection(Ray ray, out IntersectionPoint intersectionPoint, out float t)
{
	intersectionPoint.position = 0;
	intersectionPoint.color = 0;
	intersectionPoint.normal = 0;

	float minT = 5873200;
	int minIndex = -1;

	for (int i = 0; i < sphereCount; i++)
	{
		if (RaySphereIntersection(spheres[i], ray, t))
		{
			if (t < minT)
			{
				minIndex = i;
				minT = t;
			}
		}
	}

	float sceneT=0;


	if (minIndex != -1)
	{
		sceneT = minT;
		intersectionPoint.position = ray.origin + ray.direction * sceneT;
		intersectionPoint.color = spheres[minIndex].color;
		intersectionPoint.normal = normalize(intersectionPoint.position - spheres[minIndex].center);
		//return true;
	}
	//else
	//{
	//	intersectionPoint.position = 0;
	//	intersectionPoint.color = 0;
	//	intersectionPoint.normal = 0;
	//	return false;
	//}

	float groundT=0;
	bool intersectionWithScene = minIndex != -1;
	bool intersectionWithGround = RayPlaneIntersection(float3(0, 0, -1), float3(0, 0, -10), ray, groundT);
	if (intersectionWithScene || intersectionWithGround)
	{
		if (intersectionWithScene && intersectionWithGround)
		{
			if (groundT < sceneT)
			{
				intersectionPoint.normal = float3(0, 0, 1);
				intersectionPoint.position = ray.origin + ray.direction * groundT;
				intersectionPoint.color = float4(0.6, 0.6, 0.6, 1);
				t = groundT;
			}
			else
			{
				t = sceneT;
			}
		}
		else
		{
			if (intersectionWithScene)
			{
				t = sceneT;
			}
			else
			{
				intersectionPoint.normal = float3(0, 0, 1);
				intersectionPoint.position = ray.origin + ray.direction * groundT;
				intersectionPoint.color = float4(0.6, 0.6, 0.6, 1);
				t = groundT;
			}
		}
		return true;
	}
	return false;
}

bool InShadow(const Ray shadowRay, const Light light)
{
	IntersectionPoint intersectionPoint;
	float maxT = length(light.position - shadowRay.origin);
	float intersectionT;
	if (FindClosestIntersection(shadowRay, intersectionPoint, intersectionT) && intersectionT < maxT)
	{
		return true;
	}

	return false;
}

float4 Shade(const IntersectionPoint intersectionPoint, const Ray ray)
{
	float4 output = 0;
	//TODO ambient?
	Ray shadowRay;

	for (int i = 0; i < lightCount; i++)
	{
		CalculateShadowRay(intersectionPoint, ray, lights[i], shadowRay);

		if (!InShadow(shadowRay, lights[i]))
		{
			output += PhongIllumination(intersectionPoint, ray, lights[i]);
		}
	}

	return output;
}

void Trace(Ray ray, out float4 outputColor)
{
	IntersectionPoint intersectionPoint;
	float t;
	if (FindClosestIntersection(ray, intersectionPoint, t))
	{
		outputColor = Shade(intersectionPoint, ray);
	}
	else
	{
		outputColor = float4(0.5, 0.5, 0.5, 1);
	}
}

[numthreads(16,16,1)]
void main(uint3 threadId : SV_DispatchThreadID)
{
	float2 ssPos = float2(threadId.xy);
	float2 dimension = float2(width, height);
	ssPos = ssPos / dimension;
	ssPos = ssPos * 2 - 1;

	float3 pixelWorldPos = nearPlaneCenter + nearPlaneUp * -ssPos.y + nearPlaneSide * ssPos.x;
	float3 rayDir = normalize(pixelWorldPos - mCameraPos);
	Ray ray;
	ray.direction = rayDir;
	ray.origin = mCameraPos;
	float4 oc;
	Trace(ray, oc);

	renderTarget[uint2(threadId.x, threadId.y)] = oc;
}

